{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#agenthelm","title":"AgentHelm","text":"<p>Production-Ready Orchestration for AI Agents.</p> <p>AgentHelm is a lightweight Python framework for building AI agents with a focus on production-readiness. It provides the essential orchestration layer to make your agents observable, reliable, and safe.</p> <p>In the rapidly evolving world of AI agents, many frameworks focus on rapid prototyping. AgentHelm is different. It's built on the premise that for agents to be trusted in real-world, production environments, they need the same level of observability and control as traditional software.</p> <p>If you've ever struggled to debug a failing agent or worried about deploying an agent that interacts with real-world systems, AgentHelm is for you.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Traceable Execution: Automatically log every tool call, its inputs, outputs, errors, and execution time. Get a complete, structured audit trail of your agent's actions.</li> <li>Human-in-the-Loop: Mark sensitive tools (e.g., <code>charge_credit_card</code>) with a <code>@tool(requires_approval=True)</code> decorator to ensure a human must approve the action before it runs.</li> <li>Resilient Workflows: Define automatic retries for flaky tools that might fail due to transient network errors.</li> <li>Transactional Safety: Implement automatic rollbacks for multi-step workflows. If a step fails, AgentHelm can run compensating actions to undo the previous steps.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-installation","title":"1. Installation","text":"<pre><code>pip install agenthelm\n</code></pre>"},{"location":"#2-create-your-tools","title":"2. Create your Tools","text":"<p>Create a Python file (e.g., <code>tools.py</code>) and define your functions with the <code>@tool</code> decorator. AgentHelm automatically parses the function signature to build the contract.</p> <pre><code># tools.py\nfrom agenthelm import tool\n\n@tool()\ndef get_weather(city: str) -&gt; str:\n    \"\"\"Gets the current weather for a given city.\"\"\"\n    if city == \"New York\":\n        return \"It is 24\u00b0C and sunny in New York.\"\n    else:\n        return f\"Sorry, I don't know the weather for {city}.\"\n\n@tool(requires_approval=True)\ndef post_tweet(message: str) -&gt; dict:\n    \"\"\"Posts a message to a social media feed.\"\"\"\n    print(f\"TWEETING: {message}\")\n    return {\"status\": \"posted\"}\n</code></pre>"},{"location":"#3-environment-variables","title":"3. Environment Variables","text":"<p>AgentHelm requires API keys for the Large Language Models (LLMs) it interacts with. Set these as environment variables:</p> <ul> <li>Mistral AI: Set <code>MISTRAL_API_KEY</code>. Optionally, set <code>MISTRAL_MODEL_NAME</code> (defaults to <code>mistral-small-latest</code>).     <pre><code>export MISTRAL_API_KEY=\"your_mistral_api_key_here\"\n# export MISTRAL_MODEL_NAME=\"mistral-large-latest\"\n</code></pre></li> <li>OpenAI: Set <code>OPENAI_API_KEY</code>. Optionally, set <code>OPENAI_MODEL_NAME</code> (defaults to <code>gpt-4</code>).     <pre><code>export OPENAI_API_KEY=\"your_openai_api_key_here\"\n# export OPENAI_MODEL_NAME=\"gpt-3.5-turbo\"\n</code></pre></li> </ul>"},{"location":"#4-run-the-agent","title":"4. Run the Agent","text":"<p>Use the <code>agenthelm</code> command-line tool to run your agent. The CLI handles everything from setting up the agent to running the reasoning loop and logging the traces.</p> <pre><code># Run the agent from your terminal\nagenthelm run \\\n  --agent-file examples/cli_tools_example/my_agent_tools.py \\\n  --task \"What is the weather in New York?\"\n\n# For verbose output, add the -v or --verbose flag\nagenthelm run \\\n  --agent-file examples/cli_tools_example/my_agent_tools.py \\\n  --task \"What is the weather in New York?\" \\\n  --llm-type mistral \\\n  --verbose\n\n# To specify the output trace file, use the --trace-file option\nagenthelm run \\\n  --agent-file examples/cli_tools_example/my_agent_tools.py \\\n  --task \"What is the weather in New York?\" \\\n  --trace-file my_trace.json\n</code></pre> <p>This will produce a detailed trace file (by default <code>cli_trace.json</code>), giving you a perfect record of the agent's execution.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides a detailed API reference for all public classes and functions in AgentHelm.</p>"},{"location":"api_reference/#core","title":"Core","text":""},{"location":"api_reference/#the-tool-decorator","title":"The <code>@tool</code> Decorator","text":""},{"location":"api_reference/#agenthelm.tool","title":"tool","text":""},{"location":"api_reference/#agenthelm.tool-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.tool.TOOL_REGISTRY","title":"TOOL_REGISTRY  <code>module-attribute</code>","text":"<pre><code>TOOL_REGISTRY = {}\n</code></pre>"},{"location":"api_reference/#agenthelm.tool-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.tool.tool","title":"tool","text":"<pre><code>tool(\n    inputs=None,\n    outputs=None,\n    side_effects=None,\n    max_cost=0.0,\n    requires_approval=False,\n    retries=0,\n    compensating_tool=None,\n    timeout=30.0,\n    tags=None,\n)\n</code></pre> <p>A decorator to register a function as a tool in the orchestration framework. If 'inputs' or 'outputs' are not provided, they will be inferred from the function's type hints.</p> Source code in <code>agenthelm\\core\\tool.py</code> <pre><code>def tool(\n    inputs: dict = None,\n    outputs: dict = None,\n    side_effects: list[str] = None,\n    max_cost: float = 0.0,\n    requires_approval: bool = False,\n    retries: int = 0,\n    compensating_tool: str = None,\n    timeout: float = 30.0,\n    tags: list[str] = None,\n):\n    \"\"\"\n    A decorator to register a function as a tool in the orchestration framework.\n    If 'inputs' or 'outputs' are not provided, they will be inferred from the function's type hints.\n    \"\"\"\n\n    def tool_decorator(func: Callable) -&gt; Callable:\n        \"\"\"This is the actual decorator that wraps the function and builds the contract.\"\"\"\n        tool_name = func.__name__\n\n        # --- Introspection Logic ---\n        sig = inspect.signature(func)\n\n        # Infer inputs from type hints if not provided\n        introspected_inputs = {\n            param.name: param.annotation.__name__\n            for param in sig.parameters.values()\n            if param.kind == param.POSITIONAL_OR_KEYWORD\n        }\n\n        # Infer outputs from return type hint if not provided\n        introspected_outputs = {}\n        if sig.return_annotation is not inspect.Signature.empty:\n            # For simplicity, we'll assume the output is a dict with a single key 'result'\n            introspected_outputs = {\"result\": sig.return_annotation.__name__}\n\n        # --- Contract Creation ---\n        final_inputs = inputs if inputs is not None else introspected_inputs\n        final_outputs = outputs if outputs is not None else introspected_outputs\n\n        contract = {\n            \"inputs\": final_inputs,\n            \"outputs\": final_outputs,\n            \"side_effects\": side_effects or [],\n            \"max_cost\": max_cost,\n            \"requires_approval\": requires_approval,\n            \"retries\": retries,\n            \"compensating_tool\": compensating_tool,\n            \"timeout\": timeout,\n            \"tags\": tags or [],\n        }\n\n        # Register the tool and its contract\n        TOOL_REGISTRY[tool_name] = {\"function\": func, \"contract\": contract}\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            # The orchestrator will use the registry to perform checks\n            # before this wrapper is ever called.\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return tool_decorator\n</code></pre>"},{"location":"api_reference/#tool-registry","title":"Tool Registry","text":""},{"location":"api_reference/#agenthelm.TOOL_REGISTRY","title":"TOOL_REGISTRY  <code>module-attribute</code>","text":"<pre><code>TOOL_REGISTRY = {}\n</code></pre>"},{"location":"api_reference/#execution-tracer","title":"Execution Tracer","text":""},{"location":"api_reference/#agenthelm.ExecutionTracer","title":"ExecutionTracer","text":"<pre><code>ExecutionTracer(\n    storage, approval_handler=None, session_id=None\n)\n</code></pre> Source code in <code>agenthelm\\core\\tracer.py</code> <pre><code>def __init__(\n    self,\n    storage: BaseStorage,\n    approval_handler: ApprovalHandler | None = None,\n    session_id: str | None = None,\n):\n    self.storage = storage\n    self.approval_handler = approval_handler or CliHandler()\n    self.session_id = session_id or str(uuid.uuid4())\n\n    # Context for next trace\n    self._current_reasoning: str | None = None\n    self._current_confidence: float = 1.0\n    self._current_agent_name: str | None = None\n</code></pre>"},{"location":"api_reference/#agenthelm.ExecutionTracer-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.ExecutionTracer.set_trace_context","title":"set_trace_context","text":"<pre><code>set_trace_context(reasoning, confidence, agent_name=None)\n</code></pre> <p>Sets the LLM reasoning context for the next trace event.</p> Source code in <code>agenthelm\\core\\tracer.py</code> <pre><code>def set_trace_context(\n    self,\n    reasoning: str,\n    confidence: float,\n    agent_name: str | None = None,\n):\n    \"\"\"Sets the LLM reasoning context for the next trace event.\"\"\"\n    self._current_reasoning = reasoning\n    self._current_confidence = confidence\n    self._current_agent_name = agent_name\n</code></pre>"},{"location":"api_reference/#event-model","title":"Event Model","text":""},{"location":"api_reference/#agenthelm.Event","title":"Event","text":"<p>               Bases: <code>BaseModel</code></p> <p>timestamp: When the event happened. tool_name: The name of the tool that was called. inputs: The arguments the tool was called with. outputs: What the tool returned. execution_time: How long it took to run. error_state: Any error that occurred, or null if it succeeded. llm_reasoning_trace: (For now, this can be a placeholder string). confidence_score: (For now, this can be a placeholder float, like 1.0).</p>"},{"location":"api_reference/#agenthelm.Event-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.Event.agent_name","title":"agent_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>agent_name = None\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.confidence_score","title":"confidence_score  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>confidence_score = 1.0\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.error_state","title":"error_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error_state = None\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.estimated_cost_usd","title":"estimated_cost_usd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>estimated_cost_usd = 0.0\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.inputs","title":"inputs  <code>instance-attribute</code>","text":"<pre><code>inputs\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.llm_reasoning_trace","title":"llm_reasoning_trace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>llm_reasoning_trace = 'placeholder'\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.outputs","title":"outputs  <code>instance-attribute</code>","text":"<pre><code>outputs\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.retry_count","title":"retry_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_count = 0\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.session_id","title":"session_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session_id = None\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.token_usage","title":"token_usage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token_usage = None\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.tool_name","title":"tool_name  <code>instance-attribute</code>","text":"<pre><code>tool_name\n</code></pre>"},{"location":"api_reference/#agenthelm.Event.trace_id","title":"trace_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trace_id = None\n</code></pre>"},{"location":"api_reference/#token-usage","title":"Token Usage","text":""},{"location":"api_reference/#agenthelm.TokenUsage","title":"TokenUsage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Token usage from an LLM call.</p>"},{"location":"api_reference/#agenthelm.TokenUsage-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.TokenUsage.input_tokens","title":"input_tokens  <code>instance-attribute</code>","text":"<pre><code>input_tokens\n</code></pre>"},{"location":"api_reference/#agenthelm.TokenUsage.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model\n</code></pre>"},{"location":"api_reference/#agenthelm.TokenUsage.output_tokens","title":"output_tokens  <code>instance-attribute</code>","text":"<pre><code>output_tokens\n</code></pre>"},{"location":"api_reference/#agenthelm.TokenUsage.total_tokens","title":"total_tokens  <code>property</code>","text":"<pre><code>total_tokens\n</code></pre>"},{"location":"api_reference/#cost-tracking","title":"Cost Tracking","text":""},{"location":"api_reference/#costtracker","title":"CostTracker","text":""},{"location":"api_reference/#agenthelm.CostTracker","title":"CostTracker","text":"<pre><code>CostTracker(pricing=None, pricing_file=None)\n</code></pre> <p>               Bases: <code>BaseCostTracker</code></p> <p>Tracks token usage and estimates costs based on pricing table.</p> <p>Initialize CostTracker.</p> <p>Parameters:</p> Name Type Description Default <code>pricing</code> <code>dict[str, dict[str, float]] | None</code> <p>Custom pricing dict {model: {input: $, output: $}} per 1M tokens</p> <code>None</code> <code>pricing_file</code> <code>str | Path | None</code> <p>Path to YAML file with pricing config</p> <code>None</code> Source code in <code>agenthelm\\core\\cost.py</code> <pre><code>def __init__(\n    self,\n    pricing: dict[str, dict[str, float]] | None = None,\n    pricing_file: str | Path | None = None,\n):\n    \"\"\"\n    Initialize CostTracker.\n\n    Args:\n        pricing: Custom pricing dict {model: {input: $, output: $}} per 1M tokens\n        pricing_file: Path to YAML file with pricing config\n    \"\"\"\n    self.total_input_tokens = 0\n    self.total_output_tokens = 0\n    self.total_cost = 0.0\n    self.usages: list[TokenUsage] = []\n\n    # Load pricing (priority: pricing_file &gt; pricing &gt; DEFAULT_PRICING)\n    if pricing_file:\n        self.pricing = self._load_pricing_file(pricing_file)\n    elif pricing:\n        self.pricing = pricing\n    else:\n        self.pricing = self.DEFAULT_PRICING.copy()\n</code></pre>"},{"location":"api_reference/#agenthelm.CostTracker-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.CostTracker.get_summary","title":"get_summary","text":"<pre><code>get_summary()\n</code></pre> <p>Get a summary of usage and costs.</p> Source code in <code>agenthelm\\core\\cost.py</code> <pre><code>def get_summary(self) -&gt; dict[str, Any]:\n    \"\"\"Get a summary of usage and costs.\"\"\"\n    return {\n        \"total_input_tokens\": self.total_input_tokens,\n        \"total_output_tokens\": self.total_output_tokens,\n        \"total_tokens\": self.get_total_tokens(),\n        \"total_cost_usd\": round(self.total_cost, 6),\n        \"num_calls\": len(self.usages),\n    }\n</code></pre>"},{"location":"api_reference/#factory-function","title":"Factory Function","text":""},{"location":"api_reference/#agenthelm.get_cost_tracker","title":"get_cost_tracker","text":"<pre><code>get_cost_tracker(\n    tokens_only=False, pricing=None, pricing_file=None\n)\n</code></pre> <p>Factory function to create the appropriate CostTracker.</p> <p>Parameters:</p> Name Type Description Default <code>tokens_only</code> <code>bool</code> <p>If True, returns TokenOnlyCostTracker (no cost calculation)</p> <code>False</code> <code>pricing</code> <code>dict[str, dict[str, float]] | None</code> <p>Custom pricing dict (only used if tokens_only=False)</p> <code>None</code> <code>pricing_file</code> <code>str | Path | None</code> <p>Path to YAML pricing config (only used if tokens_only=False)</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseCostTracker</code> <p>BaseCostTracker instance</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker = get_cost_tracker()  # Full tracking with default pricing\n&gt;&gt;&gt; tracker = get_cost_tracker(tokens_only=True)  # Token counting only\n&gt;&gt;&gt; tracker = get_cost_tracker(pricing_file=\"my_pricing.yaml\")\n</code></pre> Source code in <code>agenthelm\\core\\cost.py</code> <pre><code>def get_cost_tracker(\n    tokens_only: bool = False,\n    pricing: dict[str, dict[str, float]] | None = None,\n    pricing_file: str | Path | None = None,\n) -&gt; BaseCostTracker:\n    \"\"\"\n    Factory function to create the appropriate CostTracker.\n\n    Args:\n        tokens_only: If True, returns TokenOnlyCostTracker (no cost calculation)\n        pricing: Custom pricing dict (only used if tokens_only=False)\n        pricing_file: Path to YAML pricing config (only used if tokens_only=False)\n\n    Returns:\n        BaseCostTracker instance\n\n    Examples:\n        &gt;&gt;&gt; tracker = get_cost_tracker()  # Full tracking with default pricing\n        &gt;&gt;&gt; tracker = get_cost_tracker(tokens_only=True)  # Token counting only\n        &gt;&gt;&gt; tracker = get_cost_tracker(pricing_file=\"my_pricing.yaml\")\n    \"\"\"\n    if tokens_only:\n        return TokenOnlyCostTracker()\n    else:\n        return CostTracker(pricing=pricing, pricing_file=pricing_file)\n</code></pre>"},{"location":"api_reference/#approval-handlers","title":"Approval Handlers","text":""},{"location":"api_reference/#agenthelm.ApprovalHandler","title":"ApprovalHandler","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api_reference/#agenthelm.ApprovalHandler-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.ApprovalHandler.request_approval","title":"request_approval  <code>abstractmethod</code>","text":"<pre><code>request_approval(tool_name, arguments)\n</code></pre> Source code in <code>agenthelm\\core\\handlers.py</code> <pre><code>@abstractmethod\ndef request_approval(self, tool_name: str, arguments: dict) -&gt; bool: ...\n</code></pre>"},{"location":"api_reference/#agenthelm.CliHandler","title":"CliHandler","text":"<p>               Bases: <code>ApprovalHandler</code></p>"},{"location":"api_reference/#agenthelm.CliHandler-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.CliHandler.request_approval","title":"request_approval","text":"<pre><code>request_approval(tool_name, arguments)\n</code></pre> Source code in <code>agenthelm\\core\\handlers.py</code> <pre><code>def request_approval(self, tool_name: str, arguments: dict) -&gt; bool:\n    return (\n        input(\n            f\"Approve execution for tool {tool_name} with arguments {arguments}? (y/n): \"\n        ).lower()\n        == \"y\"\n    )\n</code></pre>"},{"location":"api_reference/#agenthelm.AutoApproveHandler","title":"AutoApproveHandler","text":"<p>               Bases: <code>ApprovalHandler</code></p> <p>Auto-approve for CI/testing.</p>"},{"location":"api_reference/#agenthelm.AutoApproveHandler-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.AutoApproveHandler.request_approval","title":"request_approval","text":"<pre><code>request_approval(tool_name, arguments)\n</code></pre> Source code in <code>agenthelm\\core\\handlers.py</code> <pre><code>def request_approval(self, tool_name: str, arguments: dict) -&gt; bool:\n    return True\n</code></pre>"},{"location":"api_reference/#agenthelm.AutoDenyHandler","title":"AutoDenyHandler","text":"<p>               Bases: <code>ApprovalHandler</code></p> <p>Auto-deny (useful for dry-run mode).</p>"},{"location":"api_reference/#agenthelm.AutoDenyHandler-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.AutoDenyHandler.request_approval","title":"request_approval","text":"<pre><code>request_approval(tool_name, arguments)\n</code></pre> Source code in <code>agenthelm\\core\\handlers.py</code> <pre><code>def request_approval(self, tool_name: str, arguments: dict) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api_reference/#storage","title":"Storage","text":""},{"location":"api_reference/#basestorage","title":"BaseStorage","text":""},{"location":"api_reference/#agenthelm.core.storage.BaseStorage","title":"BaseStorage","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for trace storage backends.</p>"},{"location":"api_reference/#agenthelm.core.storage.BaseStorage-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.core.storage.BaseStorage.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(event)\n</code></pre> <p>Save a single trace event.</p> Source code in <code>agenthelm\\core\\storage\\base.py</code> <pre><code>@abstractmethod\ndef save(self, event: Dict[str, Any]) -&gt; None:\n    \"\"\"Save a single trace event.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.BaseStorage.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load()\n</code></pre> <p>Load all trace events.</p> Source code in <code>agenthelm\\core\\storage\\base.py</code> <pre><code>@abstractmethod\ndef load(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Load all trace events.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.BaseStorage.query","title":"query","text":"<pre><code>query(filters=None)\n</code></pre> <p>Optional: Query traces with filters.</p> Source code in <code>agenthelm\\core\\storage\\base.py</code> <pre><code>def query(self, filters: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"Optional: Query traces with filters.\"\"\"\n    return self.load()\n</code></pre>"},{"location":"api_reference/#jsonstorage","title":"JsonStorage","text":""},{"location":"api_reference/#agenthelm.core.storage.JsonStorage","title":"JsonStorage","text":"<pre><code>JsonStorage(file_path)\n</code></pre> <p>               Bases: <code>BaseStorage</code></p> Source code in <code>agenthelm\\core\\storage\\json_storage.py</code> <pre><code>def __init__(self, file_path: str):\n    self.file_path = file_path\n    # Create the file with an empty list if it doesn't exist\n    if not self.exists():\n        with open(self.file_path, \"w\") as f:\n            json.dump([], f)\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.JsonStorage-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.core.storage.JsonStorage.file_path","title":"file_path  <code>instance-attribute</code>","text":"<pre><code>file_path = file_path\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.JsonStorage-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.core.storage.JsonStorage.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Check if the storage file exists.</p> Source code in <code>agenthelm\\core\\storage\\json_storage.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the storage file exists.\"\"\"\n    return os.path.exists(self.file_path)\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.JsonStorage.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data from a JSON file. Returns a list of dictionaries.</p> Source code in <code>agenthelm\\core\\storage\\json_storage.py</code> <pre><code>def load(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Load data from a JSON file. Returns a list of dictionaries.\"\"\"\n    if not self.exists():\n        return []\n    with open(self.file_path, \"r\") as f:\n        try:\n            return json.load(f)\n        except json.JSONDecodeError:\n            return []\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.JsonStorage.save","title":"save","text":"<pre><code>save(data, override=False)\n</code></pre> <p>Save data to a JSON file. If override is True, it will replace the entire file content. If override is False, it will append the data to the existing list.</p> Source code in <code>agenthelm\\core\\storage\\json_storage.py</code> <pre><code>def save(self, data: Dict[str, Any], override=False) -&gt; None:\n    \"\"\"\n    Save data to a JSON file.\n    If override is True, it will replace the entire file content.\n    If override is False, it will append the data to the existing list.\n    \"\"\"\n    if override:\n        with open(self.file_path, \"w\") as f:\n            json.dump([data], f, indent=2, default=str)\n    else:\n        current_data = self.load()\n        current_data.append(data)\n        with open(self.file_path, \"w\") as f:\n            json.dump(current_data, f, indent=2, default=str)\n</code></pre>"},{"location":"api_reference/#sqlitestorage","title":"SqliteStorage","text":""},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage","title":"SqliteStorage","text":"<pre><code>SqliteStorage(db_path)\n</code></pre> <p>               Bases: <code>BaseStorage</code></p> Source code in <code>agenthelm\\core\\storage\\sqlite_storage.py</code> <pre><code>def __init__(self, db_path: str):\n    self.db_path = db_path\n    self._create_table_if_not_exists()\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage.db_path","title":"db_path  <code>instance-attribute</code>","text":"<pre><code>db_path = db_path\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage.load","title":"load","text":"<pre><code>load()\n</code></pre> Source code in <code>agenthelm\\core\\storage\\sqlite_storage.py</code> <pre><code>def load(self) -&gt; List[Dict[str, Any]]:\n    conn = sqlite3.connect(self.db_path)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM traces ORDER BY timestamp DESC\")\n    rows = cursor.fetchall()\n    conn.close()\n\n    # Convert rows to a list of dictionaries\n    columns = [description[0] for description in cursor.description]\n    results = []\n    for row in rows:\n        item = dict(zip(columns, row))\n        # Parse JSON fields\n        if item.get(\"inputs\"):\n            item[\"inputs\"] = json.loads(item[\"inputs\"])\n        if item.get(\"outputs\"):\n            item[\"outputs\"] = json.loads(item[\"outputs\"])\n        if item.get(\"token_usage\"):\n            item[\"token_usage\"] = json.loads(item[\"token_usage\"])\n        results.append(item)\n    return results\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage.query","title":"query","text":"<pre><code>query(filters=None)\n</code></pre> <p>Query traces with SQL-level filtering for better performance.</p> Source code in <code>agenthelm\\core\\storage\\sqlite_storage.py</code> <pre><code>def query(self, filters: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"Query traces with SQL-level filtering for better performance.\"\"\"\n    conn = sqlite3.connect(self.db_path)\n    cursor = conn.cursor()\n\n    query = \"SELECT * FROM traces WHERE 1=1\"\n    params = []\n\n    if filters:\n        if \"tool_name\" in filters:\n            query += \" AND tool_name = ?\"\n            params.append(filters[\"tool_name\"])\n        if \"agent_name\" in filters:\n            query += \" AND agent_name = ?\"\n            params.append(filters[\"agent_name\"])\n        if \"session_id\" in filters:\n            query += \" AND session_id = ?\"\n            params.append(filters[\"session_id\"])\n        if \"status\" in filters:\n            if filters[\"status\"].lower() == \"success\":\n                query += \" AND error_state IS NULL\"\n            else:\n                query += \" AND error_state IS NOT NULL\"\n\n    query += \" ORDER BY timestamp DESC\"\n    cursor.execute(query, params)\n    rows = cursor.fetchall()\n    conn.close()\n\n    # Convert rows to dictionaries\n    columns = [description[0] for description in cursor.description]\n    results = []\n    for row in rows:\n        item = dict(zip(columns, row))\n        # Parse JSON fields\n        if item.get(\"inputs\"):\n            item[\"inputs\"] = json.loads(item[\"inputs\"])\n        if item.get(\"outputs\"):\n            item[\"outputs\"] = json.loads(item[\"outputs\"])\n        if item.get(\"token_usage\"):\n            item[\"token_usage\"] = json.loads(item[\"token_usage\"])\n        results.append(item)\n    return results\n</code></pre>"},{"location":"api_reference/#agenthelm.core.storage.SqliteStorage.save","title":"save","text":"<pre><code>save(event)\n</code></pre> Source code in <code>agenthelm\\core\\storage\\sqlite_storage.py</code> <pre><code>def save(self, event: Dict[str, Any]) -&gt; None:\n    conn = sqlite3.connect(self.db_path)\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"\n        INSERT INTO traces (\n            timestamp, tool_name, inputs, outputs, execution_time, \n            error_state, llm_reasoning_trace, confidence_score,\n            token_usage, estimated_cost_usd, retry_count,\n            agent_name, session_id, trace_id\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    \"\"\",\n        (\n            event.get(\"timestamp\"),\n            event.get(\"tool_name\"),\n            json.dumps(event.get(\"inputs\", {})),\n            json.dumps(event.get(\"outputs\", {})),\n            event.get(\"execution_time\"),\n            event.get(\"error_state\"),\n            event.get(\"llm_reasoning_trace\"),\n            event.get(\"confidence_score\"),\n            json.dumps(event.get(\"token_usage\"))\n            if event.get(\"token_usage\")\n            else None,\n            event.get(\"estimated_cost_usd\", 0.0),\n            event.get(\"retry_count\", 0),\n            event.get(\"agent_name\"),\n            event.get(\"session_id\"),\n            event.get(\"trace_id\"),\n        ),\n    )\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"api_reference/#memory-hub","title":"Memory Hub","text":""},{"location":"api_reference/#memoryhub","title":"MemoryHub","text":""},{"location":"api_reference/#agenthelm.MemoryHub","title":"MemoryHub","text":"<pre><code>MemoryHub(\n    data_dir=None,\n    redis_url=None,\n    qdrant_url=None,\n    collection_name=None,\n    embedding_model=None,\n)\n</code></pre> <p>Unified interface to AgentHelm memory backends.</p> <p>Provides access to both short-term (key-value) and semantic (vector) memory with automatic backend selection based on configuration.</p> <p>Examples:</p>"},{"location":"api_reference/#agenthelm.MemoryHub--in-memory-default-zero-config-ephemeral","title":"In-memory (default) - zero config, ephemeral","text":"<p>hub = MemoryHub()</p>"},{"location":"api_reference/#agenthelm.MemoryHub--local-persistence-no-docker-needed","title":"Local persistence - no Docker needed","text":"<p>hub = MemoryHub(data_dir=\"./data\")</p>"},{"location":"api_reference/#agenthelm.MemoryHub--network-mode-for-production-scaling","title":"Network mode - for production scaling","text":"<p>hub = MemoryHub(redis_url=\"redis://...\", qdrant_url=\"http://...\")</p> <p>Initialize MemoryHub.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>str | Path | None</code> <p>Directory for local persistence. If provided, uses local mode.</p> <code>None</code> <code>redis_url</code> <code>str | None</code> <p>Redis server URL. If provided, uses Redis for short-term.</p> <code>None</code> <code>qdrant_url</code> <code>str | None</code> <p>Qdrant server URL. If provided, uses network Qdrant.</p> <code>None</code> <code>collection_name</code> <code>str | None</code> <p>Custom Qdrant collection name.</p> <code>None</code> <code>embedding_model</code> <code>str | None</code> <p>Custom embedding model for semantic memory.</p> <code>None</code> Source code in <code>agenthelm\\memory\\hub.py</code> <pre><code>def __init__(\n    self,\n    # Mode selection\n    data_dir: str | Path | None = None,\n    # Network backends (optional)\n    redis_url: str | None = None,\n    qdrant_url: str | None = None,\n    # Advanced options\n    collection_name: str | None = None,\n    embedding_model: str | None = None,\n):\n    \"\"\"\n    Initialize MemoryHub.\n\n    Args:\n        data_dir: Directory for local persistence. If provided, uses local mode.\n        redis_url: Redis server URL. If provided, uses Redis for short-term.\n        qdrant_url: Qdrant server URL. If provided, uses network Qdrant.\n        collection_name: Custom Qdrant collection name.\n        embedding_model: Custom embedding model for semantic memory.\n    \"\"\"\n    self._short_term: BaseShortTermMemory | None = None\n    self._semantic: BaseSemanticMemory | None = None\n\n    # Determine modes based on configuration\n    self._data_dir = Path(data_dir) if data_dir else None\n    self._redis_url = redis_url\n    self._qdrant_url = qdrant_url\n    self._collection_name = collection_name\n    self._embedding_model = embedding_model\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryHub-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.MemoryHub.short_term","title":"short_term  <code>property</code>","text":"<pre><code>short_term\n</code></pre> <p>Get short-term memory backend (lazy initialization).</p>"},{"location":"api_reference/#agenthelm.MemoryHub.semantic","title":"semantic  <code>property</code>","text":"<pre><code>semantic\n</code></pre> <p>Get semantic memory backend (lazy initialization).</p>"},{"location":"api_reference/#agenthelm.MemoryHub-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.MemoryHub.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close all backends and release resources.</p> Source code in <code>agenthelm\\memory\\hub.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close all backends and release resources.\"\"\"\n    if self._short_term:\n        await self._short_term.close()\n    if self._semantic:\n        await self._semantic.close()\n</code></pre>"},{"location":"api_reference/#memorycontext","title":"MemoryContext","text":""},{"location":"api_reference/#agenthelm.MemoryContext","title":"MemoryContext","text":"<pre><code>MemoryContext(hub, session_id=None, cleanup_on_exit=True)\n</code></pre> <p>Session-scoped context manager for memory operations.</p> <p>Provides a scoped namespace within the MemoryHub for a single session, preventing key collisions between concurrent sessions and enabling easy cleanup of session-specific data.</p> <p>Examples:</p>"},{"location":"api_reference/#agenthelm.MemoryContext--using-with-async-context-manager","title":"Using with async context manager","text":"<p>async with MemoryContext(hub, session_id=\"user-123\") as ctx:     await ctx.set(\"last_query\", \"What is AI?\")     await ctx.store_memory(\"User asked about AI basics.\")</p>"},{"location":"api_reference/#agenthelm.MemoryContext--manual-lifecycle-management","title":"Manual lifecycle management","text":"<p>ctx = MemoryContext(hub) await ctx.set(\"key\", \"value\") await ctx.cleanup()  # Clean up session data</p> <p>Initialize MemoryContext.</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>MemoryHub</code> <p>The MemoryHub instance to use</p> required <code>session_id</code> <code>str | None</code> <p>Optional session identifier (auto-generated if not provided)</p> <code>None</code> <code>cleanup_on_exit</code> <code>bool</code> <p>Whether to clean up session data on exit</p> <code>True</code> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>def __init__(\n    self,\n    hub: MemoryHub,\n    session_id: str | None = None,\n    cleanup_on_exit: bool = True,\n):\n    \"\"\"\n    Initialize MemoryContext.\n\n    Args:\n        hub: The MemoryHub instance to use\n        session_id: Optional session identifier (auto-generated if not provided)\n        cleanup_on_exit: Whether to clean up session data on exit\n    \"\"\"\n    self.hub = hub\n    self.session_id = session_id or str(uuid.uuid4())\n    self.cleanup_on_exit = cleanup_on_exit\n    self._stored_memory_ids: list[str] = []\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryContext-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.MemoryContext.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>Get a session-scoped value.</p> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>async def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get a session-scoped value.\"\"\"\n    return await self.hub.short_term.get(self._scoped_key(key))\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryContext.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ttl=3600)\n</code></pre> <p>Set a session-scoped value with TTL.</p> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>async def set(self, key: str, value: Any, ttl: int = 3600) -&gt; None:\n    \"\"\"Set a session-scoped value with TTL.\"\"\"\n    await self.hub.short_term.set(self._scoped_key(key), value, ttl)\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryContext.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Delete a session-scoped key.</p> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>async def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a session-scoped key.\"\"\"\n    await self.hub.short_term.delete(self._scoped_key(key))\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryContext.store_memory","title":"store_memory  <code>async</code>","text":"<pre><code>store_memory(text, metadata=None)\n</code></pre> <p>Store a memory with session metadata.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to store</p> required <code>metadata</code> <code>dict[str, Any] | None</code> <p>Additional metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the stored memory</p> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>async def store_memory(\n    self,\n    text: str,\n    metadata: dict[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"\n    Store a memory with session metadata.\n\n    Args:\n        text: The text to store\n        metadata: Additional metadata\n\n    Returns:\n        The ID of the stored memory\n    \"\"\"\n    full_metadata = {\"session_id\": self.session_id}\n    if metadata:\n        full_metadata.update(metadata)\n\n    memory_id = await self.hub.semantic.store(text, metadata=full_metadata)\n    self._stored_memory_ids.append(memory_id)\n    return memory_id\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryContext.recall","title":"recall  <code>async</code>","text":"<pre><code>recall(query, top_k=5, session_only=False)\n</code></pre> <p>Search semantic memory.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>top_k</code> <code>int</code> <p>Number of results to return</p> <code>5</code> <code>session_only</code> <code>bool</code> <p>If True, only search within this session's memories</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>List of SearchResult objects</p> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>async def recall(\n    self,\n    query: str,\n    top_k: int = 5,\n    session_only: bool = False,\n) -&gt; list:\n    \"\"\"\n    Search semantic memory.\n\n    Args:\n        query: Search query\n        top_k: Number of results to return\n        session_only: If True, only search within this session's memories\n\n    Returns:\n        List of SearchResult objects\n    \"\"\"\n    filter_dict = None\n    if session_only:\n        filter_dict = {\"session_id\": self.session_id}\n\n    return await self.hub.semantic.search(query, top_k=top_k, filter=filter_dict)\n</code></pre>"},{"location":"api_reference/#agenthelm.MemoryContext.cleanup","title":"cleanup  <code>async</code>","text":"<pre><code>cleanup()\n</code></pre> <p>Clean up all session-scoped short-term memory keys.</p> Source code in <code>agenthelm\\memory\\context.py</code> <pre><code>async def cleanup(self) -&gt; None:\n    \"\"\"Clean up all session-scoped short-term memory keys.\"\"\"\n    pattern = f\"session:{self.session_id}:*\"\n    keys = await self.hub.short_term.keys(pattern)\n    for key in keys:\n        await self.hub.short_term.delete(key)\n</code></pre>"},{"location":"api_reference/#short-term-memory","title":"Short-Term Memory","text":""},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory","title":"InMemoryShortTermMemory","text":"<pre><code>InMemoryShortTermMemory()\n</code></pre> <p>               Bases: <code>BaseShortTermMemory</code></p> <p>In-memory key-value store with TTL support.</p> <p>Uses lazy expiration: expired entries are removed on access. No external dependencies required.</p> Example <p>memory = InMemoryShortTermMemory() await memory.set(\"user:123:name\", \"Alice\", ttl=3600) name = await memory.get(\"user:123:name\")</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>def __init__(self):\n    # Storage: {key: (value, expiry_timestamp)}\n    # expiry_timestamp is None for no expiration\n    self._store: dict[str, tuple[Any, float | None]] = {}\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return number of stored items (including expired ones).</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of stored items (including expired ones).\"\"\"\n    return len(self._store)\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear all stored data.</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all stored data.\"\"\"\n    self._store.clear()\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Delete a key if it exists.</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>async def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a key if it exists.\"\"\"\n    self._store.pop(key, None)\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key)\n</code></pre> <p>Check if key exists and is not expired.</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if key exists and is not expired.\"\"\"\n    if key not in self._store:\n        return False\n\n    _, expiry = self._store[key]\n\n    if expiry is not None and time.time() &gt; expiry:\n        del self._store[key]\n        return False\n\n    return True\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>Get a value by key. Returns None if not found or expired.</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>async def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get a value by key. Returns None if not found or expired.\"\"\"\n    if key not in self._store:\n        return None\n\n    value, expiry = self._store[key]\n\n    # Check if expired\n    if expiry is not None and time.time() &gt; expiry:\n        del self._store[key]\n        return None\n\n    return value\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys)\n</code></pre> <p>Get multiple keys efficiently.</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>async def get_many(self, keys: list[str]) -&gt; dict[str, Any]:\n    \"\"\"Get multiple keys efficiently.\"\"\"\n    result = {}\n    for key in keys:\n        value = await self.get(key)\n        if value is not None:\n            result[key] = value\n    return result\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.keys","title":"keys  <code>async</code>","text":"<pre><code>keys(pattern='*')\n</code></pre> <p>List keys matching a pattern.</p> <p>Supports simple wildcards: - '' matches everything - 'prefix:' matches keys starting with 'prefix:' - '*:suffix' matches keys ending with ':suffix'</p> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>async def keys(self, pattern: str = \"*\") -&gt; list[str]:\n    \"\"\"\n    List keys matching a pattern.\n\n    Supports simple wildcards:\n    - '*' matches everything\n    - 'prefix:*' matches keys starting with 'prefix:'\n    - '*:suffix' matches keys ending with ':suffix'\n    \"\"\"\n    import fnmatch\n\n    # Clean up expired keys first\n    now = time.time()\n    expired = [\n        k for k, (_, exp) in self._store.items() if exp is not None and now &gt; exp\n    ]\n    for key in expired:\n        del self._store[key]\n\n    # Match pattern\n    return [k for k in self._store.keys() if fnmatch.fnmatch(k, pattern)]\n</code></pre>"},{"location":"api_reference/#agenthelm.InMemoryShortTermMemory.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ttl=3600)\n</code></pre> <p>Set a value with TTL in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to store under</p> required <code>value</code> <code>Any</code> <p>Any JSON-serializable value</p> required <code>ttl</code> <code>int</code> <p>Time-to-live in seconds (default: 1 hour, 0 for no expiration)</p> <code>3600</code> Source code in <code>agenthelm\\memory\\short_term\\in_memory.py</code> <pre><code>async def set(self, key: str, value: Any, ttl: int = 3600) -&gt; None:\n    \"\"\"\n    Set a value with TTL in seconds.\n\n    Args:\n        key: The key to store under\n        value: Any JSON-serializable value\n        ttl: Time-to-live in seconds (default: 1 hour, 0 for no expiration)\n    \"\"\"\n    if ttl &gt; 0:\n        expiry = time.time() + ttl\n    else:\n        expiry = None\n\n    self._store[key] = (value, expiry)\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory","title":"SqliteShortTermMemory","text":"<pre><code>SqliteShortTermMemory(db_path)\n</code></pre> <p>               Bases: <code>BaseShortTermMemory</code></p> <p>SQLite-based key-value store with TTL support.</p> <p>Provides persistent local storage without requiring Docker or network services. Uses lazy TTL expiration on access.</p> Example <p>memory = SqliteShortTermMemory(db_path=\"./data/short_term.db\") await memory.set(\"user:123:name\", \"Alice\", ttl=3600) name = await memory.get(\"user:123:name\")</p> <p>Initialize SQLite short-term memory.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str | Path</code> <p>Path to the SQLite database file</p> required Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>def __init__(self, db_path: str | Path):\n    \"\"\"\n    Initialize SQLite short-term memory.\n\n    Args:\n        db_path: Path to the SQLite database file\n    \"\"\"\n    self.db_path = Path(db_path)\n    self.db_path.parent.mkdir(parents=True, exist_ok=True)\n    self._init_db()\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.db_path","title":"db_path  <code>instance-attribute</code>","text":"<pre><code>db_path = Path(db_path)\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear all stored data.</p> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all stored data.\"\"\"\n    with self._get_connection() as conn:\n        conn.execute(\"DELETE FROM kv_store\")\n        conn.commit()\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close resources (no-op for SQLite, connections are per-operation).</p> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close resources (no-op for SQLite, connections are per-operation).\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Delete a key if it exists.</p> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>async def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a key if it exists.\"\"\"\n    with self._get_connection() as conn:\n        conn.execute(\"DELETE FROM kv_store WHERE key = ?\", (key,))\n        conn.commit()\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key)\n</code></pre> <p>Check if key exists and is not expired.</p> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if key exists and is not expired.\"\"\"\n    with self._get_connection() as conn:\n        cursor = conn.execute(\"SELECT expiry FROM kv_store WHERE key = ?\", (key,))\n        row = cursor.fetchone()\n\n        if row is None:\n            return False\n\n        expiry = row[0]\n\n        if expiry is not None and time.time() &gt; expiry:\n            conn.execute(\"DELETE FROM kv_store WHERE key = ?\", (key,))\n            conn.commit()\n            return False\n\n        return True\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>Get a value by key. Returns None if not found or expired.</p> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>async def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get a value by key. Returns None if not found or expired.\"\"\"\n    with self._get_connection() as conn:\n        cursor = conn.execute(\n            \"SELECT value, expiry FROM kv_store WHERE key = ?\", (key,)\n        )\n        row = cursor.fetchone()\n\n        if row is None:\n            return None\n\n        value_json, expiry = row\n\n        # Check if expired\n        if expiry is not None and time.time() &gt; expiry:\n            conn.execute(\"DELETE FROM kv_store WHERE key = ?\", (key,))\n            conn.commit()\n            return None\n\n        return json.loads(value_json)\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.keys","title":"keys  <code>async</code>","text":"<pre><code>keys(pattern='*')\n</code></pre> <p>List keys matching a pattern.</p> <p>Note: Uses SQL LIKE pattern matching (% for wildcard). '*' is converted to '%' for SQL compatibility.</p> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>async def keys(self, pattern: str = \"*\") -&gt; list[str]:\n    \"\"\"\n    List keys matching a pattern.\n\n    Note: Uses SQL LIKE pattern matching (% for wildcard).\n    '*' is converted to '%' for SQL compatibility.\n    \"\"\"\n    sql_pattern = pattern.replace(\"*\", \"%\")\n\n    # Clean up expired keys first\n    now = time.time()\n    with self._get_connection() as conn:\n        conn.execute(\n            \"DELETE FROM kv_store WHERE expiry IS NOT NULL AND expiry &lt; ?\", (now,)\n        )\n        cursor = conn.execute(\n            \"SELECT key FROM kv_store WHERE key LIKE ?\", (sql_pattern,)\n        )\n        return [row[0] for row in cursor.fetchall()]\n</code></pre>"},{"location":"api_reference/#agenthelm.SqliteShortTermMemory.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ttl=3600)\n</code></pre> <p>Set a value with TTL in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to store under</p> required <code>value</code> <code>Any</code> <p>Any JSON-serializable value</p> required <code>ttl</code> <code>int</code> <p>Time-to-live in seconds (default: 1 hour, 0 for no expiration)</p> <code>3600</code> Source code in <code>agenthelm\\memory\\short_term\\sqlite.py</code> <pre><code>async def set(self, key: str, value: Any, ttl: int = 3600) -&gt; None:\n    \"\"\"\n    Set a value with TTL in seconds.\n\n    Args:\n        key: The key to store under\n        value: Any JSON-serializable value\n        ttl: Time-to-live in seconds (default: 1 hour, 0 for no expiration)\n    \"\"\"\n    if ttl &gt; 0:\n        expiry = time.time() + ttl\n    else:\n        expiry = None\n\n    value_json = json.dumps(value)\n\n    with self._get_connection() as conn:\n        conn.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO kv_store (key, value, expiry) \n            VALUES (?, ?, ?)\n            \"\"\",\n            (key, value_json, expiry),\n        )\n        conn.commit()\n</code></pre>"},{"location":"api_reference/#semantic-memory","title":"Semantic Memory","text":""},{"location":"api_reference/#agenthelm.SemanticMemory","title":"SemanticMemory","text":"<pre><code>SemanticMemory(\n    mode=\"memory\",\n    path=None,\n    url=None,\n    collection_name=None,\n    embedding_model=None,\n)\n</code></pre> <p>               Bases: <code>BaseSemanticMemory</code></p> <p>Semantic memory using Qdrant vector database.</p> <p>Supports three modes: - \"memory\": In-memory, ephemeral (no persistence) - \"local\": Local file storage (persistent, no Docker) - \"network\": Remote Qdrant server (production scaling)</p> <p>Uses Qdrant's FastEmbed for automatic embedding generation.</p> Example <p>Initialize SemanticMemory.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>\"memory\", \"local\", or \"network\"</p> <code>'memory'</code> <code>path</code> <code>str | None</code> <p>Directory for local mode storage</p> <code>None</code> <code>url</code> <code>str | None</code> <p>Qdrant server URL for network mode</p> <code>None</code> <code>collection_name</code> <code>str | None</code> <p>Name of the Qdrant collection</p> <code>None</code> <code>embedding_model</code> <code>str | None</code> <p>FastEmbed model name</p> <code>None</code> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>def __init__(\n    self,\n    mode: str = \"memory\",\n    path: str | None = None,\n    url: str | None = None,\n    collection_name: str | None = None,\n    embedding_model: str | None = None,\n):\n    \"\"\"\n    Initialize SemanticMemory.\n\n    Args:\n        mode: \"memory\", \"local\", or \"network\"\n        path: Directory for local mode storage\n        url: Qdrant server URL for network mode\n        collection_name: Name of the Qdrant collection\n        embedding_model: FastEmbed model name\n    \"\"\"\n    self.mode = mode\n    self.collection_name = collection_name or self.DEFAULT_COLLECTION\n    self.embedding_model = embedding_model or self.DEFAULT_EMBEDDING_MODEL\n\n    # Initialize Qdrant client based on mode\n    if mode == \"memory\":\n        self.client = QdrantClient(\":memory:\")\n    elif mode == \"local\":\n        if path is None:\n            path = \"./qdrant_data\"\n        self.client = QdrantClient(path=path)\n    elif mode == \"network\":\n        if url is None:\n            url = \"http://localhost:6333\"\n        self.client = QdrantClient(url=url)\n    else:\n        raise ValueError(\n            f\"Unknown mode: {mode}. Use 'memory', 'local', or 'network'.\"\n        )\n\n    # Track if collection is initialized\n    self._collection_initialized = False\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory--in-memory-default","title":"In-memory (default)","text":"<p>memory = SemanticMemory()</p>"},{"location":"api_reference/#agenthelm.SemanticMemory--local-file-persistence","title":"Local file persistence","text":"<p>memory = SemanticMemory(mode=\"local\", path=\"./data/qdrant\")</p>"},{"location":"api_reference/#agenthelm.SemanticMemory--network-dockercloud","title":"Network (Docker/Cloud)","text":"<p>memory = SemanticMemory(mode=\"network\", url=\"http://localhost:6333\")</p>"},{"location":"api_reference/#agenthelm.SemanticMemory-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.SemanticMemory.DEFAULT_COLLECTION","title":"DEFAULT_COLLECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_COLLECTION = 'agenthelm_memory'\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.DEFAULT_EMBEDDING_MODEL","title":"DEFAULT_EMBEDDING_MODEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_EMBEDDING_MODEL = (\n    \"sentence-transformers/all-MiniLM-L6-v2\"\n)\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client = QdrantClient(':memory:')\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.collection_name","title":"collection_name  <code>instance-attribute</code>","text":"<pre><code>collection_name = collection_name or DEFAULT_COLLECTION\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.embedding_model","title":"embedding_model  <code>instance-attribute</code>","text":"<pre><code>embedding_model = embedding_model or DEFAULT_EMBEDDING_MODEL\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.mode","title":"mode  <code>instance-attribute</code>","text":"<pre><code>mode = mode\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory-functions","title":"Functions","text":""},{"location":"api_reference/#agenthelm.SemanticMemory.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Delete all entries in the collection.</p> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Delete all entries in the collection.\"\"\"\n    if self._collection_initialized:\n        self.client.delete_collection(self.collection_name)\n        self._collection_initialized = False\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the Qdrant client.</p> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the Qdrant client.\"\"\"\n    self.client.close()\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(ids)\n</code></pre> <p>Delete entries by ID.</p> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>async def delete(self, ids: list[str]) -&gt; None:\n    \"\"\"Delete entries by ID.\"\"\"\n    self._ensure_collection()\n\n    self.client.delete(\n        collection_name=self.collection_name,\n        points_selector=ids,\n    )\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.search","title":"search  <code>async</code>","text":"<pre><code>search(query, top_k=5, filter=None)\n</code></pre> <p>Search for similar texts. Returns ranked results.</p> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>async def search(\n    self,\n    query: str,\n    top_k: int = 5,\n    filter: dict[str, Any] | None = None,\n) -&gt; list[SearchResult]:\n    \"\"\"Search for similar texts. Returns ranked results.\"\"\"\n    self._ensure_collection()\n\n    query_embedding = self._embed_text(query)\n\n    # Build filter if provided\n    qdrant_filter = None\n    if filter:\n        conditions = [\n            FieldCondition(key=k, match=MatchValue(value=v))\n            for k, v in filter.items()\n        ]\n        qdrant_filter = Filter(must=conditions)\n\n    results = self.client.search(\n        collection_name=self.collection_name,\n        query_vector=query_embedding,\n        query_filter=qdrant_filter,\n        limit=top_k,\n    )\n\n    return [\n        SearchResult(\n            id=str(hit.id),\n            text=hit.payload.get(\"text\", \"\"),\n            score=hit.score,\n            metadata={k: v for k, v in hit.payload.items() if k != \"text\"},\n        )\n        for hit in results\n    ]\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.store","title":"store  <code>async</code>","text":"<pre><code>store(text, metadata=None, id=None)\n</code></pre> <p>Store text with optional metadata. Returns the ID.</p> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>async def store(\n    self,\n    text: str,\n    metadata: dict[str, Any] | None = None,\n    id: str | None = None,\n) -&gt; str:\n    \"\"\"Store text with optional metadata. Returns the ID.\"\"\"\n    self._ensure_collection()\n\n    if id is None:\n        id = str(uuid.uuid4())\n\n    embedding = self._embed_text(text)\n\n    payload = {\"text\": text}\n    if metadata:\n        payload.update(metadata)\n\n    self.client.upsert(\n        collection_name=self.collection_name,\n        points=[\n            PointStruct(\n                id=id,\n                vector=embedding,\n                payload=payload,\n            )\n        ],\n    )\n\n    return id\n</code></pre>"},{"location":"api_reference/#agenthelm.SemanticMemory.store_many","title":"store_many  <code>async</code>","text":"<pre><code>store_many(texts, metadatas=None)\n</code></pre> <p>Store multiple texts efficiently.</p> Source code in <code>agenthelm\\memory\\semantic.py</code> <pre><code>async def store_many(\n    self,\n    texts: list[str],\n    metadatas: list[dict[str, Any]] | None = None,\n) -&gt; list[str]:\n    \"\"\"Store multiple texts efficiently.\"\"\"\n    self._ensure_collection()\n\n    points = []\n    ids = []\n\n    for i, text in enumerate(texts):\n        id = str(uuid.uuid4())\n        ids.append(id)\n\n        embedding = self._embed_text(text)\n\n        payload = {\"text\": text}\n        if metadatas and i &lt; len(metadatas):\n            payload.update(metadatas[i])\n\n        points.append(\n            PointStruct(\n                id=id,\n                vector=embedding,\n                payload=payload,\n            )\n        )\n\n    self.client.upsert(\n        collection_name=self.collection_name,\n        points=points,\n    )\n\n    return ids\n</code></pre>"},{"location":"api_reference/#search-results","title":"Search Results","text":""},{"location":"api_reference/#agenthelm.SearchResult","title":"SearchResult  <code>dataclass</code>","text":"<pre><code>SearchResult(id, text, score, metadata=None)\n</code></pre> <p>Result from semantic memory search.</p>"},{"location":"api_reference/#agenthelm.SearchResult-attributes","title":"Attributes","text":""},{"location":"api_reference/#agenthelm.SearchResult.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id\n</code></pre>"},{"location":"api_reference/#agenthelm.SearchResult.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata = None\n</code></pre>"},{"location":"api_reference/#agenthelm.SearchResult.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score\n</code></pre>"},{"location":"api_reference/#agenthelm.SearchResult.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text\n</code></pre>"},{"location":"api_reference/#agenthelm.SearchResult-functions","title":"Functions","text":""},{"location":"concepts/","title":"Core Concepts","text":"<p>This section explains the fundamental ideas behind AgentHelm.</p>"},{"location":"concepts/#tool-contracts","title":"Tool Contracts","text":"<p>Tools are the building blocks of agent actions. AgentHelm uses a decorator-based approach to define tools with rich metadata:</p> <pre><code>from agenthelm import tool\n\n@tool(\n    requires_approval=True,  # Human-in-the-loop\n    max_retries=3,           # Automatic retries\n    timeout=30.0,            # Execution timeout\n    tags=[\"financial\", \"sensitive\"]\n)\ndef charge_credit_card(amount: float, card_id: str) -&gt; dict:\n    \"\"\"Charge a credit card for the specified amount.\"\"\"\n    return {\"status\": \"charged\", \"transaction_id\": \"txn_123\"}\n</code></pre> <p>The <code>@tool</code> decorator automatically:</p> <ul> <li>Extracts the function signature and docstring</li> <li>Registers the tool in <code>TOOL_REGISTRY</code></li> <li>Enables execution tracing and cost tracking</li> </ul>"},{"location":"concepts/#execution-tracing","title":"Execution Tracing","text":"<p>The <code>ExecutionTracer</code> records every tool call with rich metadata:</p> <pre><code>from agenthelm import ExecutionTracer\nfrom agenthelm.core.storage import JsonStorage\n\ntracer = ExecutionTracer(storage=JsonStorage(\"trace.json\"))\ntracer.set_trace_context(agent_name=\"my_agent\")\n\n# Execute a tool with full tracing\nevent = tracer.execute(my_tool, arg1=\"value\", arg2=123)\n\n# Event contains: timestamp, inputs, outputs, duration, token_usage, cost, etc.\n</code></pre>"},{"location":"concepts/#event-model","title":"Event Model","text":"<p>Every execution produces an <code>Event</code> with these fields:</p> Field Description <code>timestamp</code> When the event occurred <code>tool_name</code> Name of the executed tool <code>inputs</code> / <code>outputs</code> Arguments and return value <code>execution_duration_ms</code> How long it took <code>token_usage</code> LLM tokens (input/output/model) <code>estimated_cost_usd</code> Cost estimate based on pricing <code>agent_name</code> Which agent executed this <code>session_id</code> Session identifier <code>trace_id</code> Unique execution ID"},{"location":"concepts/#cost-tracking","title":"Cost Tracking","text":"<p>AgentHelm includes built-in cost tracking for LLM usage:</p> <pre><code>from agenthelm import CostTracker, get_cost_tracker\n\n# Token-only tracking (no pricing)\ntracker = get_cost_tracker(tokens_only=True)\n\n# Full cost tracking with pricing\ntracker = get_cost_tracker()  # Uses built-in pricing.yaml\n\n# Track usage\ntracker.record(\"gpt-4o\", input_tokens=500, output_tokens=150)\n\n# Get summary\nsummary = tracker.get_summary()\n# {\n#     \"total_input_tokens\": 500,\n#     \"total_output_tokens\": 150,\n#     \"total_cost_usd\": 0.0055,\n#     \"by_model\": {...}\n# }\n</code></pre>"},{"location":"concepts/#approval-handlers","title":"Approval Handlers","text":"<p>Control human-in-the-loop behavior with different handlers:</p> <pre><code>from agenthelm import CliHandler, AutoApproveHandler, AutoDenyHandler\n\n# Interactive CLI approval\ntracer = ExecutionTracer(approval_handler=CliHandler())\n\n# Auto-approve all (for testing)\ntracer = ExecutionTracer(approval_handler=AutoApproveHandler())\n\n# Auto-deny all (for dry-run)\ntracer = ExecutionTracer(approval_handler=AutoDenyHandler())\n</code></pre>"},{"location":"concepts/#storage-backends","title":"Storage Backends","text":"<p>Events can be stored in different backends:</p> <pre><code>from agenthelm.core.storage import JsonStorage, SqliteStorage\n\n# JSON file (simple, portable)\nstorage = JsonStorage(\"traces.json\")\n\n# SQLite (queryable, indexed)\nstorage = SqliteStorage(\"traces.db\")\n\n# Query by session\nevents = storage.query(session_id=\"abc-123\", limit=100)\n</code></pre>"},{"location":"concepts/#reliability-features","title":"Reliability Features","text":""},{"location":"concepts/#retries","title":"Retries","text":"<pre><code>@tool(max_retries=3, retry_delay=1.0)\ndef flaky_api_call(endpoint: str) -&gt; dict:\n    \"\"\"Call an external API that might fail.\"\"\"\n    return requests.get(endpoint).json()\n</code></pre>"},{"location":"concepts/#human-approval","title":"Human Approval","text":"<pre><code>@tool(requires_approval=True)\ndef delete_file(path: str) -&gt; bool:\n    \"\"\"Delete a file (requires human approval).\"\"\"\n    os.remove(path)\n    return True\n</code></pre>"},{"location":"concepts/#compensating-actions","title":"Compensating Actions","text":"<pre><code>@tool(compensating_tool=\"restore_file\")\ndef archive_file(path: str) -&gt; str:\n    \"\"\"Archive a file (can be rolled back).\"\"\"\n    archive_path = f\"{path}.archived\"\n    shutil.move(path, archive_path)\n    return archive_path\n\n@tool()\ndef restore_file(archive_path: str) -&gt; str:\n    \"\"\"Restore an archived file.\"\"\"\n    original_path = archive_path.replace(\".archived\", \"\")\n    shutil.move(archive_path, original_path)\n    return original_path\n</code></pre>"},{"location":"memory/","title":"Memory Hub","text":"<p>AgentHelm's Memory Hub provides a pluggable memory system with an SDK-first design. Zero Docker required for basic usage.</p>"},{"location":"memory/#quick-start","title":"Quick Start","text":"<pre><code>from agenthelm import MemoryHub, MemoryContext\n\n# In-memory (default, ephemeral)\nhub = MemoryHub()\n\n# Short-term memory (key-value)\nawait hub.short_term.set(\"user:123:name\", \"Alice\", ttl=3600)\nname = await hub.short_term.get(\"user:123:name\")\n\n# Semantic memory (vector search)\nawait hub.semantic.store(\"User prefers dark mode.\", metadata={\"category\": \"preferences\"})\nresults = await hub.semantic.search(\"What are the user's UI preferences?\")\n</code></pre>"},{"location":"memory/#architecture","title":"Architecture","text":"<p>The Memory Hub offers three tiers, automatically selected based on configuration:</p> Tier Short-Term Semantic Use Case In-Memory <code>dict</code> + TTL Qdrant <code>:memory:</code> Development, testing Local File SQLite Qdrant local Single-node, no Docker Network Redis Qdrant server Production, scaling"},{"location":"memory/#configuration","title":"Configuration","text":""},{"location":"memory/#in-memory-default","title":"In-Memory (Default)","text":"<pre><code>hub = MemoryHub()  # Zero config, ephemeral\n</code></pre>"},{"location":"memory/#local-persistence","title":"Local Persistence","text":"<pre><code>hub = MemoryHub(data_dir=\"./data\")\n# Creates:\n#   ./data/short_term.db  (SQLite)\n#   ./data/qdrant/        (Qdrant local)\n</code></pre>"},{"location":"memory/#network-production","title":"Network (Production)","text":"<pre><code>hub = MemoryHub(\n    redis_url=\"redis://localhost:6379\",\n    qdrant_url=\"http://localhost:6333\"\n)\n</code></pre>"},{"location":"memory/#session-context","title":"Session Context","text":"<p>Use <code>MemoryContext</code> for session-scoped operations with automatic key namespacing:</p> <pre><code>async with MemoryContext(hub, session_id=\"user-123\") as ctx:\n    # Keys are automatically prefixed with session ID\n    await ctx.set(\"last_query\", \"What is AI?\")\n\n    # Store memories tagged with session\n    await ctx.store_memory(\"User asked about AI basics.\")\n\n    # Search within session or globally\n    results = await ctx.recall(\"AI questions\", session_only=True)\n\n# Session keys are cleaned up on exit (configurable)\n</code></pre>"},{"location":"memory/#short-term-memory-api","title":"Short-Term Memory API","text":""},{"location":"memory/#agenthelm.memory.base.BaseShortTermMemory","title":"BaseShortTermMemory","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for short-term (key-value) memory.</p>"},{"location":"memory/#agenthelm.memory.base.BaseShortTermMemory-functions","title":"Functions","text":""},{"location":"memory/#agenthelm.memory.base.BaseShortTermMemory.get","title":"get  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>Get a value by key. Returns None if not found or expired.</p>"},{"location":"memory/#agenthelm.memory.base.BaseShortTermMemory.set","title":"set  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set(key, value, ttl=3600)\n</code></pre> <p>Set a value with optional TTL in seconds.</p>"},{"location":"memory/#agenthelm.memory.base.BaseShortTermMemory.delete","title":"delete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Delete a key.</p>"},{"location":"memory/#agenthelm.memory.base.BaseShortTermMemory.exists","title":"exists  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>exists(key)\n</code></pre> <p>Check if key exists and is not expired.</p>"},{"location":"memory/#semantic-memory-api","title":"Semantic Memory API","text":""},{"location":"memory/#agenthelm.memory.base.BaseSemanticMemory","title":"BaseSemanticMemory","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for semantic (vector) memory.</p>"},{"location":"memory/#agenthelm.memory.base.BaseSemanticMemory-functions","title":"Functions","text":""},{"location":"memory/#agenthelm.memory.base.BaseSemanticMemory.store","title":"store  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>store(text, metadata=None, id=None)\n</code></pre> <p>Store text with optional metadata. Returns the ID.</p>"},{"location":"memory/#agenthelm.memory.base.BaseSemanticMemory.search","title":"search  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>search(query, top_k=5, filter=None)\n</code></pre> <p>Search for similar texts. Returns ranked results.</p>"},{"location":"memory/#agenthelm.memory.base.BaseSemanticMemory.delete","title":"delete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete(ids)\n</code></pre> <p>Delete entries by ID.</p>"},{"location":"memory/#agenthelm.memory.base.BaseSemanticMemory.store_many","title":"store_many  <code>async</code>","text":"<pre><code>store_many(texts, metadatas=None)\n</code></pre> <p>Store multiple texts. Default implementation calls store() for each.</p>"},{"location":"memory/#backend-selection","title":"Backend Selection","text":"<p>AgentHelm automatically selects the appropriate backend:</p> <pre><code># Explicit backend usage\nfrom agenthelm.memory import InMemoryShortTermMemory, SqliteShortTermMemory, SemanticMemory\n\n# In-memory short-term\nmemory = InMemoryShortTermMemory()\n\n# SQLite short-term\nmemory = SqliteShortTermMemory(db_path=\"./data/cache.db\")\n\n# Semantic with mode selection\nsemantic = SemanticMemory(mode=\"memory\")  # or \"local\" or \"network\"\n</code></pre>"},{"location":"observability/","title":"Observability &amp; Trace Explorer","text":"<p>AgentHelm v0.2.0 introduces a robust observability system and a powerful CLI-based trace explorer, allowing you to gain deep insights into your agent's execution, debug issues, and ensure reliability.</p>"},{"location":"observability/#standardized-logging","title":"Standardized Logging","text":"<p>All internal <code>print()</code> statements have been replaced with Python's standard <code>logging</code> module. This provides granular control over the verbosity of output.</p> <ul> <li><code>logging.info()</code>: Used for high-level, user-facing messages, indicating major steps in the agent's execution.</li> <li><code>logging.debug()</code>: Provides detailed information, such as LLM responses, tool arguments, and internal processing   steps. Useful for in-depth debugging.</li> <li><code>logging.warning()</code>: Indicates non-critical issues or potential problems.</li> <li><code>logging.error()</code>: Signals critical errors that prevent the agent from completing its task.</li> </ul>"},{"location":"observability/#controlling-logging-verbosity","title":"Controlling Logging Verbosity","text":"<p>Use the <code>-v</code> or <code>--verbose</code> flag when running your agent to enable <code>DEBUG</code>-level logging:</p> <pre><code>agenthelm run \\\n  --agent-file examples/cli_tools_example/my_agent_tools.py \\\n  --task \"What is the weather in New York?\" \\\n  --verbose\n</code></pre> <p>By default, only <code>INFO</code> level messages and above are displayed.</p>"},{"location":"observability/#storage-abstraction-layer","title":"Storage Abstraction Layer","text":"<p>AgentHelm now features a flexible storage abstraction layer, allowing you to choose how your agent's execution traces are persisted. This enables better integration with different environments and provides options for performance and querying capabilities.</p>"},{"location":"observability/#available-storage-backends","title":"Available Storage Backends","text":"<ul> <li>JSON Storage (<code>.json</code>): This is the default storage backend. Traces are saved as a list of JSON objects in a   single file. It's simple, human-readable, and excellent for local development and smaller trace volumes.</li> </ul> <pre><code>from agenthelm.core.storage import JsonStorage\nstorage = JsonStorage(\"my_agent_traces.json\")\n</code></pre> <ul> <li>SQLite Storage (<code>.db</code>): A lightweight, file-based relational database. SQLite offers significantly better   performance for querying and filtering large numbers of traces compared to JSON files. It's recommended for more   extensive trace logging and when you need to perform complex queries.</li> </ul> <pre><code>from agenthelm.core.storage import SqliteStorage\nstorage = SqliteStorage(\"my_agent_traces.db\")\n</code></pre>"},{"location":"observability/#specifying-storage","title":"Specifying Storage","text":"<p>You can specify the storage file and type using the <code>--trace-file</code> option in the <code>agenthelm run</code> command. The backend is automatically determined by the file extension (<code>.json</code> for JSON, <code>.db</code> for SQLite).</p> <pre><code># Using JSON storage (default)\nagenthelm run --agent-file tools.py --task \"...\" --trace-file cli_trace.json\n\n# Using SQLite storage\nagenthelm run --agent-file tools.py --task \"...\" --trace-file my_traces.db\n</code></pre>"},{"location":"observability/#cli-trace-explorer","title":"CLI Trace Explorer","text":"<p>The <code>agenthelm traces</code> command provides a powerful interface to inspect, filter, and export your agent's execution traces directly from the command line.</p>"},{"location":"observability/#agenthelm-traces-list","title":"<code>agenthelm traces list</code>","text":"<p>Lists recent agent execution traces in a table format. Supports pagination.</p> <pre><code># List the 10 most recent traces from the default JSON file\nagenthelm traces list\n\n# List 5 traces starting from the 3rd trace (offset 2) from a SQLite database\nagenthelm traces list --limit 5 --offset 2 --trace-file my_traces.db\n\n# Output traces in raw JSON format\nagenthelm traces list --json\n</code></pre>"},{"location":"observability/#agenthelm-traces-show-id","title":"<code>agenthelm traces show &lt;ID&gt;</code>","text":"<p>Displays detailed information for a specific trace, including inputs, outputs, LLM reasoning, and confidence scores.</p> <pre><code># Show details for trace with ID 0 from the default JSON file\nagenthelm traces show 0\n\n# Show details for trace with ID 5 from a SQLite database\nagenthelm traces show 5 --trace-file my_traces.db\n</code></pre>"},{"location":"observability/#agenthelm-traces-filter","title":"<code>agenthelm traces filter</code>","text":"<p>Filters traces based on various criteria and displays the results in a table.</p> <pre><code># Filter traces by tool name and status\nagenthelm traces filter --tool-name get_weather --status success\n\n# Filter traces that failed within a specific date range\nagenthelm traces filter --status failed --date-from 2025-10-01 --date-to 2025-10-31 --trace-file my_traces.db\n\n# Filter traces with high execution time and low confidence, output as JSON\nagenthelm traces filter --min-time 5.0 --confidence-max 0.7 --json\n</code></pre>"},{"location":"observability/#agenthelm-traces-export","title":"<code>agenthelm traces export</code>","text":"<p>Exports filtered traces to different file formats (CSV, JSON, Markdown).</p> <pre><code># Export all failed traces to a CSV file\nagenthelm traces export --output failed_traces.csv --format csv --status failed\n\n# Export all traces to a JSON file\nagenthelm traces export --output all_traces.json --format json --trace-file my_traces.db\n\n# Export traces from a specific tool to a Markdown report\nagenthelm traces export --output weather_tool_report.md --format md --tool-name get_weather\n</code></pre>"},{"location":"tutorial/","title":"Tutorial: Building Your First Agent with AgentHelm","text":"<p>This tutorial will guide you through building a simple agent using AgentHelm, demonstrating its core features like tool definition, human approval, and rollbacks.</p>"},{"location":"tutorial/#1-setup-your-environment","title":"1. Setup Your Environment","text":"<p>First, ensure you have Python 3.12+ and a virtual environment set up. Install AgentHelm:</p> <pre><code>pip install agenthelm\n</code></pre> <p>Also, make sure you have your LLM API key set as an environment variable (e.g., <code>export MISTRAL_API_KEY=\"your_key_here\"</code>).</p>"},{"location":"tutorial/#2-define-your-tools","title":"2. Define Your Tools","text":"<p>Create a file named <code>my_agent_tools.py</code>. This file will contain the tools your agent can use.</p>"},{"location":"tutorial/#simple-tool-get_weather","title":"Simple Tool: <code>get_weather</code>","text":"<p>Let's start with a simple tool to get weather information. AgentHelm's <code>@tool</code> decorator automatically infers the tool's contract from your function's type hints.</p> <pre><code># my_agent_tools.py\nfrom agenthelm import tool\n\n@tool()\ndef get_weather(city: str) -&gt; str:\n    \"\"\"Gets the current weather for a given city.\"\"\"\n    # In a real scenario, this would call a weather API\n    if city == \"New York\":\n        return \"It is 24\u00b0C and sunny in New York.\"\n    elif city == \"London\":\n        return \"It is 15\u00b0C and cloudy in London.\"\n    else:\n        return f\"Sorry, I don't know the weather for {city}.\"\n</code></pre>"},{"location":"tutorial/#tool-requiring-human-approval-send_email","title":"Tool Requiring Human Approval: <code>send_email</code>","text":"<p>For sensitive actions, you can require human approval. AgentHelm will pause the agent's execution and prompt the user for confirmation.</p> <pre><code># my_agent_tools.py (continued)\n\n@tool(requires_approval=True)\ndef send_email(recipient: str, subject: str, body: str) -&gt; dict:\n    \"\"\"Sends an email to a specified recipient.\"\"\"\n    # In a real scenario, this would integrate with an email service\n    print(f\"[ACTION REQUIRED] Sending email to {recipient} with subject '{subject}' and body: '{body}'\")\n    return {\"status\": \"email_sent\", \"recipient\": recipient}\n</code></pre>"},{"location":"tutorial/#tool-with-rollback-create_resource-and-delete_resource","title":"Tool with Rollback: <code>create_resource</code> and <code>delete_resource</code>","text":"<p>AgentHelm supports transactional workflows with automatic rollbacks. If a multi-step process fails, it can execute compensating actions to undo previous steps.</p> <pre><code># my_agent_tools.py (continued)\n\n@tool()\ndef delete_resource(resource_id: str) -&gt; dict:\n    \"\"\"Deletes a cloud resource by its ID (compensating action).\"\"\"\n    print(f\"[COMPENSATING ACTION] Deleting resource: {resource_id}\")\n    return {\"status\": \"resource_deleted\", \"resource_id\": resource_id}\n\n@tool(compensating_tool='delete_resource')\ndef create_resource(resource_type: str, config: dict) -&gt; dict:\n    \"\"\"Creates a cloud resource with specified type and configuration.\"\"\"\n    # In a real scenario, this would call a cloud provider API\n    resource_id = f\"res-{resource_type}-{hash(str(config))}\"\n    print(f\"[ACTION] Creating resource {resource_id} of type {resource_type} with config {config}\")\n    return {\"status\": \"resource_created\", \"resource_id\": resource_id}\n\n@tool()\ndef deploy_application(resource_id: str, app_name: str) -&gt; dict:\n    \"\"\"Deploys an application to a given resource. Designed to fail for demonstration.\"\"\"\n    print(f\"[ACTION] Deploying application {app_name} to {resource_id}\")\n    raise RuntimeError(\"Deployment failed due to an unexpected error!\")\n</code></pre>"},{"location":"tutorial/#3-run-your-agent","title":"3. Run Your Agent","text":"<p>Now, let's run the agent using the <code>agenthelm</code> CLI. Make sure you are in the directory containing <code>my_agent_tools.py</code>.</p>"},{"location":"tutorial/#simple-task","title":"Simple Task","text":"<pre><code>agenthelm run \\\n  --agent-file my_agent_tools.py \\\n  --task \"What is the weather in London?\"\n</code></pre>"},{"location":"tutorial/#task-requiring-approval","title":"Task Requiring Approval","text":"<pre><code>agenthelm run \\\n  --agent-file my_agent_tools.py \\\n  --task \"Send an email to user@example.com with subject 'Hello' and body 'This is a test email.'\"\n</code></pre> <p>When you run this, the agent will pause and ask for your approval before sending the email.</p>"},{"location":"tutorial/#task-with-rollback","title":"Task with Rollback","text":"<p>Let's simulate a multi-step workflow where a later step fails, triggering a rollback.</p> <pre><code>agenthelm run \\\n  --agent-file my_agent_tools.py \\\n  --task \"First, create a 'web_server' resource with config {'size': 'medium'}. Then, deploy 'my-app' to it.\"\n</code></pre> <p>In this scenario, the <code>create_resource</code> tool will succeed, but <code>deploy_application</code> will fail. AgentHelm will then automatically call <code>delete_resource</code> (the compensating tool) to undo the <code>create_resource</code> action.</p>"},{"location":"tutorial/#4-inspect-the-trace","title":"4. Inspect the Trace","text":"<p>After each run, AgentHelm generates a <code>cli_trace.json</code> file in your current directory. This file contains a detailed, structured log of every action the agent took, including LLM reasoning, tool inputs/outputs, and any errors or rollbacks.</p> <p>Open <code>cli_trace.json</code> in a text editor to see the full observability in action.</p>"},{"location":"tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Core Concepts to understand the architecture.</li> <li>Refer to the API Reference for detailed usage of classes and functions.</li> </ul>"}]}